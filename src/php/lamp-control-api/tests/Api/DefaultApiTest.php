<?php

/**
 * Lamp Control API
 * PHP version 8.1
 *
 * @package OpenAPIServer
 * @author  OpenAPI Generator team
 * @link    https://github.com/openapitools/openapi-generator
 */

/**
 * A simple API for controlling lamps, demonstrating CRUD operations.
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


/**
 * NOTE: This class is auto generated by the openapi generator program.
 * https://github.com/openapitools/openapi-generator
 * Please update the test case below to test the endpoint.
 */

namespace OpenAPIServer\Api;

use OpenAPIServer\Api\DefaultApi;
use OpenAPIServer\Service\LampService;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;
use Slim\Psr7\Factory\StreamFactory;
use Slim\Psr7\Response;
use Slim\Psr7\Headers;
use Slim\Psr7\Request as SlimRequest;
use Slim\Psr7\Uri;

/**
 * DefaultApiTest Class Doc Comment
 *
 * @package OpenAPIServer\Api
 * @author  OpenAPI Generator team
 * @link    https://github.com/openapitools/openapi-generator
 *
 * @coversDefaultClass \OpenAPIServer\Api\DefaultApi
 */
class DefaultApiTest extends TestCase
{
    /** @var MockObject|LampService */
    private $mockService;

    /** @var DefaultApi */
    private $api;

    private function createJsonRequest(string $method, string $path, array $body = null): SlimRequest
    {
        $uri = new Uri('', '', 80, $path);
        $headers = new Headers([
            'Content-Type' => ['application/json'],
            'Accept' => ['application/json'],
        ]);
        $cookies = [];
        $serverParams = [];
        $streamFactory = new StreamFactory();
        $stream = $streamFactory->createStream($body ? (json_encode($body) ?: '{}') : '');
        return new SlimRequest($method, $uri, $headers, $cookies, $serverParams, $stream);
    }

    /**
     * Setup before running any test cases
     */
    public static function setUpBeforeClass(): void
    {
    }

    /**
     * Setup before running each test case
     */
    public function setUp(): void
    {
        parent::setUp();
        $this->mockService = $this->getMockBuilder(LampService::class)
            ->disableOriginalConstructor()
            ->getMock();
        $this->api = $this->getMockBuilder(DefaultApi::class)
            ->onlyMethods(['__construct'])
            ->disableOriginalConstructor()
            ->getMock();
        // Inject the mock service into the DefaultApi instance
        $reflection = new \ReflectionClass(DefaultApi::class);
        $serviceProp = $reflection->getProperty('service');
        $serviceProp->setAccessible(true);
        $serviceProp->setValue($this->api, $this->mockService);
    }

    /**
     * Clean up after running each test case
     */
    public function tearDown(): void
    {
    }

    /**
     * Clean up after running all test cases
     */
    public static function tearDownAfterClass(): void
    {
    }

    /**
     * Test case for createLamp
     *
     * Create a new lamp.
     *
     * @covers ::createLamp
     */
    public function testCreateLamp(): void
    {
        $now = (new \DateTime())->format(\DateTime::ATOM);
        $lampData = ['id' => '1', 'status' => true, 'createdAt' => $now, 'updatedAt' => $now];
        $lampObj = $this->createMock(\OpenAPIServer\Model\Lamp::class);
        $lampObj->method('getData')->willReturn($lampData);
        $lampObj->method('jsonSerialize')->willReturn($lampData);
        $this->mockService->expects($this->once())
            ->method('create')
            ->willReturn($lampObj);
        $this->mockService->expects($this->once())
            ->method('all')
            ->willReturn([$lampObj]);
        $this->mockService->expects($this->exactly(2))
            ->method('get')
            ->withConsecutive(['1'], ['1'])
            ->willReturnOnConsecutiveCalls($lampObj, null);
        $this->mockService->expects($this->once())
            ->method('update')
            ->willReturnCallback(function ($id, $update) use ($now) {
                // Use a fixed timestamp that's clearly different from creation time
                $updatedNow = (new \DateTime('2025-08-28 20:30:00'))->format(\DateTime::ATOM);
                // createdAt should remain unchanged, only updatedAt should be modified
                $updatedData = ['id' => '1', 'status' => false, 'createdAt' => $now, 'updatedAt' => $updatedNow];
                $updatedLamp = $this->createMock(\OpenAPIServer\Model\Lamp::class);
                $updatedLamp->method('getData')->willReturn($updatedData);
                $updatedLamp->method('jsonSerialize')->willReturn($updatedData);
                return $updatedLamp;
            });
        $this->mockService->expects($this->once())
            ->method('delete')
            ->willReturn(true);

        // Create a request to create a lamp (status only, boolean)
        $request = $this->createJsonRequest('POST', '/lamps', ['status' => true]);
        $response = new Response();
        $response = $this->api->createLamp($request, $response);
        $this->assertEquals(201, $response->getStatusCode());
        $lamp = json_decode((string)$response->getBody(), true);
        $this->assertArrayHasKey('id', $lamp);
        $this->assertArrayHasKey('status', $lamp);
        $this->assertArrayHasKey('createdAt', $lamp);
        $this->assertArrayHasKey('updatedAt', $lamp);
        $this->assertTrue($lamp['status']);
        $lampId = $lamp['id'];

        // 2. List lamps - now expects paginated response
        $request = $this->createJsonRequest('GET', '/lamps');
        $response = new Response();
        $response = $this->api->listLamps($request, $response);
        $this->assertEquals(200, $response->getStatusCode());
        $paginatedResponse = json_decode((string)$response->getBody(), true);
        $this->assertArrayHasKey('data', $paginatedResponse);
        $this->assertArrayHasKey('hasMore', $paginatedResponse);
        $this->assertArrayHasKey('nextCursor', $paginatedResponse);
        $this->assertIsArray($paginatedResponse['data']);
        $this->assertNotEmpty($paginatedResponse['data']);
        $this->assertEquals($lampId, $paginatedResponse['data'][0]['id']);

        // 3. Get lamp
        $request = $this->createJsonRequest('GET', "/lamps/{$lampId}");
        $response = new Response();
        $response = $this->api->getLamp($request, $response, (string)$lampId);
        $this->assertEquals(200, $response->getStatusCode());
        $lampFetched = json_decode((string)$response->getBody(), true);
        $this->assertEquals($lampId, $lampFetched['id']);
        $this->assertTrue($lampFetched['status']);
        $this->assertArrayHasKey('createdAt', $lampFetched);
        $this->assertArrayHasKey('updatedAt', $lampFetched);

        // 4. Update lamp (turn off)
        $request = $this->createJsonRequest('PUT', "/lamps/{$lampId}", ['status' => false]);
        $response = new Response();
        $response = $this->api->updateLamp($request, $response, (string)$lampId);
        $this->assertEquals(200, $response->getStatusCode());
        $lampUpdated = json_decode((string)$response->getBody(), true);
        $this->assertFalse($lampUpdated['status']);
        $this->assertArrayHasKey('createdAt', $lampUpdated);
        $this->assertArrayHasKey('updatedAt', $lampUpdated);
        // Verify that createdAt remains unchanged during updates
        $this->assertEquals($lamp['createdAt'], $lampUpdated['createdAt']);
        // Verify that updatedAt is different (newer) than createdAt
        $this->assertNotEquals($lampUpdated['createdAt'], $lampUpdated['updatedAt']);

        // 5. Delete lamp
        $request = $this->createJsonRequest('DELETE', "/lamps/{$lampId}");
        $response = new Response();
        $response = $this->api->deleteLamp($request, $response, (string)$lampId);
        $this->assertEquals(204, $response->getStatusCode());

        // 6. Get deleted lamp (should 404)
        $request = $this->createJsonRequest('GET', "/lamps/{$lampId}");
        $response = new Response();
        $response = $this->api->getLamp($request, $response, (string)$lampId);
        $this->assertEquals(404, $response->getStatusCode());
    }

    /**
     * Test case for createLamp with invalid JSON
     *
     * @covers ::createLamp
     */
    public function testCreateLampInvalidJson(): void
    {
        // Create a request with invalid JSON
        $uri = new Uri('', '', 80, '/lamps');
        $headers = new Headers([
            'Content-Type' => ['application/json'],
            'Accept' => ['application/json'],
        ]);
        $cookies = [];
        $serverParams = [];
        $streamFactory = new StreamFactory();
        $stream = $streamFactory->createStream('{"invalid": json}'); // Invalid JSON
        $request = new SlimRequest('POST', $uri, $headers, $cookies, $serverParams, $stream);
        
        $response = new Response();
        $api = new DefaultApi(); // Use real implementation for this test
        $response = $api->createLamp($request, $response);
        
        $this->assertEquals(400, $response->getStatusCode());
        $errorResponse = json_decode((string)$response->getBody(), true);
        $this->assertArrayHasKey('error', $errorResponse);
        $this->assertEquals('INVALID_ARGUMENT', $errorResponse['error']);
    }

    /**
     * Test case for createLamp with empty body
     *
     * @covers ::createLamp
     */
    public function testCreateLampEmptyBody(): void
    {
        $request = $this->createJsonRequest('POST', '/lamps', null);
        $response = new Response();
        $api = new DefaultApi(); // Use real implementation for this test
        $response = $api->createLamp($request, $response);
        
        $this->assertEquals(400, $response->getStatusCode());
        $errorResponse = json_decode((string)$response->getBody(), true);
        $this->assertArrayHasKey('error', $errorResponse);
        $this->assertEquals('INVALID_ARGUMENT', $errorResponse['error']);
    }

    /**
     * Test case for createLamp with missing status field
     *
     * @covers ::createLamp
     */
    public function testCreateLampMissingStatus(): void
    {
        $request = $this->createJsonRequest('POST', '/lamps', ['name' => 'test']); // Missing status
        $response = new Response();
        $api = new DefaultApi(); // Use real implementation for this test
        $response = $api->createLamp($request, $response);
        
        $this->assertEquals(400, $response->getStatusCode());
        $errorResponse = json_decode((string)$response->getBody(), true);
        $this->assertArrayHasKey('error', $errorResponse);
        $this->assertEquals('INVALID_ARGUMENT', $errorResponse['error']);
    }

    /**
     * Test case for getLamp with not found
     *
     * @covers ::getLamp
     */
    public function testGetLampNotFound(): void
    {
        $request = $this->createJsonRequest('GET', '/lamps/non-existent-id');
        $response = new Response();
        $api = new DefaultApi(); // Use real implementation for this test
        $response = $api->getLamp($request, $response, 'non-existent-id');
        
        $this->assertEquals(404, $response->getStatusCode());
    }

    /**
     * Test case for updateLamp with not found
     *
     * @covers ::updateLamp
     */
    public function testUpdateLampNotFound(): void
    {
        $request = $this->createJsonRequest('PUT', '/lamps/non-existent-id', ['status' => false]);
        $response = new Response();
        $api = new DefaultApi(); // Use real implementation for this test
        $response = $api->updateLamp($request, $response, 'non-existent-id');
        
        $this->assertEquals(404, $response->getStatusCode());
    }

    /**
     * Test case for deleteLamp with not found
     *
     * @covers ::deleteLamp
     */
    public function testDeleteLampNotFound(): void
    {
        $request = $this->createJsonRequest('DELETE', '/lamps/non-existent-id');
        $response = new Response();
        $api = new DefaultApi(); // Use real implementation for this test
        $response = $api->deleteLamp($request, $response, 'non-existent-id');
        
        $this->assertEquals(404, $response->getStatusCode());
    }

    /**
     * Test case for listLamps functionality
     *
     * @covers ::listLamps
     */
    public function testListLampsEmpty(): void
    {
        $request = $this->createJsonRequest('GET', '/lamps');
        $response = new Response();
        $api = new DefaultApi(); // Use real implementation for this test
        $response = $api->listLamps($request, $response);
        
        $this->assertEquals(200, $response->getStatusCode());
        $listResponse = json_decode((string)$response->getBody(), true);
        $this->assertArrayHasKey('data', $listResponse);
        $this->assertArrayHasKey('hasMore', $listResponse);
        $this->assertArrayHasKey('nextCursor', $listResponse);
        $this->assertIsArray($listResponse['data']);
        $this->assertFalse($listResponse['hasMore']);
        $this->assertNull($listResponse['nextCursor']);
    }

    /**
     * Test case for createLamp with array instead of object
     *
     * @covers ::createLamp
     */
    public function testCreateLampWithArray(): void
    {
        $request = $this->createJsonRequest('POST', '/lamps', [true]); // Array instead of object
        $response = new Response();
        $api = new DefaultApi(); // Use real implementation for this test
        $response = $api->createLamp($request, $response);
        
        $this->assertEquals(400, $response->getStatusCode());
        $errorResponse = json_decode((string)$response->getBody(), true);
        $this->assertArrayHasKey('error', $errorResponse);
        $this->assertEquals('INVALID_ARGUMENT', $errorResponse['error']);
        $this->assertEquals('Request body must be a JSON object, not an array', $errorResponse['details']);
    }

    /**
     * Test case for createLamp with empty string field name
     *
     * @covers ::createLamp
     */
    public function testCreateLampWithEmptyFieldName(): void
    {
        // Create a request with an empty string as field name
        $uri = new Uri('', '', 80, '/lamps');
        $headers = new Headers([
            'Content-Type' => ['application/json'],
            'Accept' => ['application/json'],
        ]);
        $cookies = [];
        $serverParams = [];
        $streamFactory = new StreamFactory();
        $stream = $streamFactory->createStream('{"": true}'); // Empty string as field name
        $request = new SlimRequest('POST', $uri, $headers, $cookies, $serverParams, $stream);
        
        $response = new Response();
        $api = new DefaultApi(); // Use real implementation for this test
        $response = $api->createLamp($request, $response);
        
        $this->assertEquals(400, $response->getStatusCode());
        $errorResponse = json_decode((string)$response->getBody(), true);
        $this->assertArrayHasKey('error', $errorResponse);
        $this->assertEquals('INVALID_ARGUMENT', $errorResponse['error']);
        $this->assertEquals('Field names cannot be empty strings', $errorResponse['details']);
    }

    /**
     * Test case for createLamp with unknown field
     *
     * @covers ::createLamp
     */
    public function testCreateLampWithUnknownField(): void
    {
        $request = $this->createJsonRequest('POST', '/lamps', ['status' => true, 'unknown' => 'value']);
        $response = new Response();
        $api = new DefaultApi(); // Use real implementation for this test
        $response = $api->createLamp($request, $response);
        
        $this->assertEquals(400, $response->getStatusCode());
        $errorResponse = json_decode((string)$response->getBody(), true);
        $this->assertArrayHasKey('error', $errorResponse);
        $this->assertEquals('INVALID_ARGUMENT', $errorResponse['error']);
        $this->assertEquals('Unknown field: unknown', $errorResponse['details']);
    }

    /**
     * Test case for createLamp with invalid status type
     *
     * @covers ::createLamp
     */
    public function testCreateLampWithInvalidStatusType(): void
    {
        $request = $this->createJsonRequest('POST', '/lamps', ['status' => 'true']); // String instead of boolean
        $response = new Response();
        $api = new DefaultApi(); // Use real implementation for this test
        $response = $api->createLamp($request, $response);
        
        $this->assertEquals(400, $response->getStatusCode());
        $errorResponse = json_decode((string)$response->getBody(), true);
        $this->assertArrayHasKey('error', $errorResponse);
        $this->assertEquals('INVALID_ARGUMENT', $errorResponse['error']);
        $this->assertEquals('Invalid format for parameter "status": expected boolean', $errorResponse['details']);
    }

    /**
     * Test case for updateLamp with various invalid inputs
     *
     * @covers ::updateLamp
     */
    public function testUpdateLampWithInvalidInputs(): void
    {
        $api = new DefaultApi(); // Use real implementation for this test
        
        // Test with array instead of object
        $request = $this->createJsonRequest('PUT', '/lamps/123', [false]);
        $response = new Response();
        $response = $api->updateLamp($request, $response, '123');
        $this->assertEquals(400, $response->getStatusCode());
        
        // Test with unknown field
        $request = $this->createJsonRequest('PUT', '/lamps/123', ['status' => false, 'unknown' => 'value']);
        $response = new Response();
        $response = $api->updateLamp($request, $response, '123');
        $this->assertEquals(400, $response->getStatusCode());
        
        // Test with invalid status type
        $request = $this->createJsonRequest('PUT', '/lamps/123', ['status' => 'false']);
        $response = new Response();
        $response = $api->updateLamp($request, $response, '123');
        $this->assertEquals(400, $response->getStatusCode());
    }

    /**
     * Test safeJsonEncode helper method indirectly by causing a JSON encode scenario
     *
     * @covers ::safeJsonEncode
     */
    public function testSafeJsonEncodeIndirectly(): void
    {
        $api = new DefaultApi(); // Use real implementation
        $request = $this->createJsonRequest('GET', '/lamps');
        $response = new Response();
        $response = $api->listLamps($request, $response);
        
        $this->assertEquals(200, $response->getStatusCode());
        $body = (string)$response->getBody();
        $this->assertJson($body); // Validates that JSON encoding worked
    }
}
